==================
CPU 例外処理モデル
==================

CPU 例外処理モデルは、ターゲットハードウェアに依存せずに決められる範囲で規定する。


------------------
CPU 例外処理の流れ
------------------

.. code-block:: none

   [CPU 例外] -+-> プロセッサ -+-> CPU 例外ハンドラ
               |               |
   [CPU 例外] -+               +-> CPU 例外ハンドラ

- CPU 例外の種類ごとに、 CPU 例外ハンドラを登録できる
- プロセッサが CPU 例外を検出すると、カーネル内の CPU 例外ハンドラの入り口処理を経由して CPU 例外ハンドラが呼び出される


CPU の状態リカバリ処理
----------------------

CPU 例外ハンドラ処理においては、 CPU 例外が発生した状態からのリカバリ処理を行う。

リカバリ処理には、大きく次の 3 つの方法がある。

a. カーネルに依存しない形で CPU 例外の原因を取り除き、実行を継続する
b. CPU 例外を起こしたタスクよりも高優先度のタスクを起動(or 待ち解除)し、そのタスクでリカバリ処理を行う
c. システム全体に対してリカバリ処理を行う(ex: システム再起動)


--------------------------------------------
CPU 例外ハンドラから呼び出せるサービスコール
--------------------------------------------

サービスコール `xsns_dpn` [#fn1]_ が返却する値によって、呼び出し可能なサービスコールが異なる。


`xsns_dpn` が `false` を返却する場合
------------------------------------

非タスクコンテキストから呼び出せる、すべてのサービスコールを呼び出せる。

(「a.」および「b.」, 「c.」のリカバリ方法が可能)


`xsns_dpn` が `true` を返却する場合
------------------------------------

下記サービスコールのみ呼び出せる。

- システムインタフェースレイヤの API
- sns_ker
- ext_ker

(「a.」および「c.」のリカバリ方法が可能)

.. [#fn1] CPU 例外発生時のディスパッチ保留状態であるかを返す。(true: ディスパッチ保留状態, false: ディスパッチ保留状態でない)


-----------------------------------
エミュレートされた CPU 例外ハンドラ
-----------------------------------

カーネルが検出したエラーを、 CPU 例外と同等に扱うことができる。

前述のエラーをカーネルが検出した場合、アプリケーションが登録したエラー処理をカーネルが呼び出せる。

エミュレートされた CPU 例外ハンドラに対しても、 CPU 例外ハンドラ番号が付与され、CPU ハンドラと同じ方法で登録できる。


-------------------------
カーネル管理外の CPU 例外
-------------------------

下記状態のいずれかで発生した例外を「カーネル管理外の CPU 例外」と呼び、
そこから起動される CPU 例外ハンドラを「カーネル管理外の CPU 例外ハンドラ」と呼ぶ。

- カーネル非動作状態
- カーネル内のクリティカルセクションの実行中
- 全割込みロック状態
- カーネル管理外の割込みハンドラ実行中

「カーネル管理外の CPU 例外ハンドラ」実行中に発生した CPU 例外も、「カーネル管理外の CPU 例外」とする。

「カーネル管理外の CPU 例外」でない CPU 例外を「カーネル管理の CPU 例外」と呼び、
「カーネル管理の CPU 例外」から起動される CPU 例外を、「カーネル管理の CPU 例外ハンドラ」と呼ぶ。

カーネル管理外の CPU 例外ハンドラにおいては、 `xsns_dpn` は `true` を返す。

.. note:: CPU 例外は、「CPU 例外が発生する状況」によって、管理内か管理外か判断されることに注意。


